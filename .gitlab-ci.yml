---
#TODO:
  # create aws credential
  # create environment using NLB/accessgw/ccm

variables:
  DOCKER_IMAGE_VERSION: "1.0"
  DOCKER_IMAGE_NAME: cdpcli-ddp
  DOCKER_IMAGE_URL: $DOCKER_REGISTRY/$ARTIFACTORY_REPOSITORY_NAME/$DOCKER_IMAGE_NAME:$DOCKER_IMAGE_VERSION
  # ENV_NAME: cdp-devo-lab-env01
  # CML_CLUSTERS: "cdp-devo-lab-env01-cml01"
  # CDE_CLUSTERS: "cdp-devo-lab-env01-cde02"
  ACTION: delete
  CDP_ENV_NAME: devo-cdp-lab-env01
  ENV: lab


# CCM is used by default for environments registered via CDP web interface, 
# but it is not used by default for environments 
# registered via CDP CLI. 
# Therefore, if you are registering your environment via 
# CDP CLI and you would like to use CCM, you must explicitly enable it during environment registration.

image: ${DOCKER_IMAGE_URL}

default:
  tags:
    - docker

stages:
  - install
  - delete
  - start
  - stop

include:
  # Common steps
  ## Environment independent
  - 'pipeline/install_cdp_env.yml'
  - 'pipeline/install_cdp_env.yml'

# cdp_env_start:
#   stage: start_env
#   script:
#     - cdp environments start-environment --environment-name $ENV_NAME || true
#     - timeout 20m bash wait_for_status.sh "ENV" "AVAILABLE"
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "provision"
#       when: manual

# cdp_env_stop:
#   stage: delete
#   script:
#     - cdp environments stop-environment --environment-name $ENV_NAME || true
#     - timeout 20m bash wait_for_status.sh "ENV" "ENV_STOPPED"
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "delete"
#       when: manual

# cml_provision:
#   stage: provision
#   before_script:
#     - cdp ml create-workspace --generate-cli-skeleton > skel.json
#   script:
#     - >
#       for CML_CLUSTER_NAME in $CML_CLUSTERS; do
#         python3 cml_json.py --action provision --cluster $CML_CLUSTER_NAME --env $ENV_NAME
#         cat ${CML_CLUSTER_NAME}.json
#         cdp --debug ml create-workspace --cli-input-json file://${CML_CLUSTER_NAME}.json || true
#       done
#     - >
#       for CML_CLUSTER_NAME in $CML_CLUSTERS; do
#         export CML_CLUSTER_NAME=$CML_CLUSTER_NAME
#         timeout 90m bash wait_for_status.sh "CML" "installation:finished"
#       done
#   artifacts:
#     paths:
#       - "*.json"
#     expire_in: 30 days
#     when: always
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "provision"
#       when: manual

# cml_delete:
#   stage: delete
#   before_script:
#     - cdp ml delete-workspace --generate-cli-skeleton > skel.json
#   script:
#     - >
#       for CML_CLUSTER_NAME in $CML_CLUSTERS; do
#         python3 cml_json.py --action delete --cluster $CML_CLUSTER_NAME --env $ENV_NAME
#         cat ${CML_CLUSTER_NAME}.json
#         cdp --debug ml delete-workspace --workspace-name $CML_CLUSTER_NAME --cli-input-json file://${CML_CLUSTER_NAME}.json || true
#       done
#     - >
#       for CML_CLUSTER_NAME in $CML_CLUSTERS; do
#         export CML_CLUSTER_NAME=$CML_CLUSTER_NAME
#         timeout 90m bash wait_for_del.sh "CML"
#       done
#   artifacts:
#     paths:
#       - "*.json"
#     expire_in: 30 days
#     when: always
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "delete"
#       when: manual

# cde_enable:
#   stage: provision
#   before_script:
#     - cdp de enable-service --generate-cli-skeleton > skel.json
#   script:
#     - >
#       for CDE_CLUSTER_NAME in $CDE_CLUSTERS; do
#         python3 cde_json.py --action provision --cluster $CDE_CLUSTER_NAME --env $ENV_NAME
#         cat ${CDE_CLUSTER_NAME}.json
#         cdp --debug de enable-service --cli-input-json file://${CDE_CLUSTER_NAME}.json || true
#       done
#     - >
#       for CDE_CLUSTER_NAME in $CDE_CLUSTERS; do
#         export CDE_CLUSTER_NAME=$CDE_CLUSTER_NAME
#         timeout 90m bash wait_for_status.sh "CDE" "ClusterCreationCompleted"
#       done
#   artifacts:
#     paths:
#       - "*.json"
#     expire_in: 30 days
#     when: always
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "provision"
#       when: manual

# cde_delete:
#   stage: delete
#   before_script:
#     - cdp de disable-service --generate-cli-skeleton > skel.json
#   script:
#     - >
#       for CDE_CLUSTER_NAME in $CDE_CLUSTERS; do
#         export CDE_CLUSTER_NAME=$CDE_CLUSTER_NAME
#         timeout 90m bash wait_for_del.sh "CDE"
#       done
#   artifacts:
#     paths:
#       - "*.json"
#     expire_in: 30 days
#     when: always
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "delete"
#       when: manual

# cde_provision_vc:
#   stage: provision
#   tags:
#     - docker
#   script:
#     - cdp de create-vc --generate-cli-skeleton > vc_skel.json
#     - cat vc_skel.json | python3 vc_cde_json_create.py > vc_env.json
#     - cat vc_env.json
#     - cdp --debug de create-vc --cli-input-json file://vc_env.json
#   artifacts:
#     paths:
#       - "*.json"
#     expire_in: 30 days
#     when: always
#   rules:
#     - if: $CI_PIPELINE_SOURCE != "schedule" && $ACTION == "delete"
#       when: manual


